<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Deserted Island Snake</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            background-color: #D2B48C; /* Sandy background */
            font-family: Arial, sans-serif;
        }
        canvas {
            border: 2px solid #2E7D32; /* Jungle green border */
            background-color: #F4E4BC; /* Sandy beige */
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            touch-action: none;
        }
        #score {
            font-size: 24px;
            margin: 10px 0;
            color: #2E7D32; /* Jungle green text */
        }
        #controls {
            display: none;
            margin-top: 10px;
        }
        #controls button {
            width: 60px;
            height: 60px;
            margin: 5px;
            font-size: 20px;
            background-color: #FF6F61; /* Coral button */
            color: white;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        #controls button:active {
            background-color: #E55A50; /* Darker coral */
        }
        #gameOverPopup, #winPopup {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            z-index: 1000;
        }
        #gameOverPopup p, #winPopup p {
            font-size: 24px;
            margin: 10px 0;
        }
        #gameOverPopup button, #winPopup button {
            padding: 10px 20px;
            font-size: 18px;
            background-color: #FF6F61; /* Coral button */
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        #gameOverPopup button:hover, #winPopup button:hover {
            background-color: #E55A50; /* Darker coral */
        }
        @media (max-width: 600px) {
            #controls { display: grid; grid-template-columns: repeat(3, 1fr); }
            #controls .empty { visibility: hidden; }
            #score { font-size: 18px; }
            #gameOverPopup p, #winPopup p { font-size: 18px; }
            #gameOverPopup button, #winPopup button { font-size: 16px; padding: 8px 16px; }
        }
    </style>
</head>
<body>
    <div id="score">Items Collected: 0</div>
    <canvas id="gameCanvas"></canvas>
    <div id="controls">
        <div class="empty"></div>
        <button id="up">‚Üë</button>
        <div class="empty"></div>
        <button id="left">‚Üê</button>
        <div class="empty"></div>
        <button id="right">‚Üí</button>
        <div class="empty"></div>
        <button id="down">‚Üì</button>
        <div class="empty"></div>
    </div>
    <div id="gameOverPopup">
        <p id="gameOverScore">Lost on the Island! Items: 0</p>
        <button id="restartButton">Try Again</button>
    </div>
    <div id="winPopup">
        <p id="winMessage">You Survived the Crash! Collected 15 Items!<br>Code: <span id="winCode"></span></p>
        <button id="winRestartButton">Play Again</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gridCount = 20;
        let gridSize;
        let snake;
        let direction;
        let nextDirection;
        let foods;
        let score;
        let gameOver;
        let availableEmojis;
        const emojiPool = ['üß≥', 'üîë', 'üîí', 'üìª', 'üõ†Ô∏è', 'üß∞', 'üõ©Ô∏è', 'üì¶', 'üß™', 'üß¥', 'üõ°Ô∏è', 'ü™ì', 'üóùÔ∏è', 'üî®', 'üßµ'];

        // Colors
        const headColor = '#000000';
        const tailColors = ['#FF6F61', '#26A69A']; // Coral and teal

        // Generate random code
        function generateCode() {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
            let code = '';
            for (let i = 0; i < 6; i++) {
                code += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return code;
        }

        // Set canvas size
        function resizeCanvas() {
            const size = Math.min(window.innerWidth, window.innerHeight) * 0.8;
            canvas.width = Math.floor(size / gridCount) * gridCount;
            canvas.height = canvas.width;
            gridSize = canvas.width / gridCount;
            resetGame();
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Reset game state
        function resetGame() {
            snake = [
                { x: 10 * gridSize, y: 10 * gridSize },
                { x: 9 * gridSize, y: 10 * gridSize },
                { x: 8 * gridSize, y: 10 * gridSize }
            ];
            direction = 'right';
            nextDirection = 'right';
            foods = [];
            availableEmojis = [...emojiPool];
            for (let i = 0; i < 3; i++) {
                spawnFood();
            }
            score = 0;
            gameOver = false;
            document.getElementById('score').textContent = 'Items Collected: 0';
            document.getElementById('gameOverPopup').style.display = 'none';
            document.getElementById('winPopup').style.display = 'none';
        }

        // Spawn a new food item
        function spawnFood() {
            if (availableEmojis.length === 0) {
                availableEmojis = [...emojiPool]; // Reset if exhausted
            }
            const emojiIndex = Math.floor(Math.random() * availableEmojis.length);
            const emoji = availableEmojis.splice(emojiIndex, 1)[0];
            let newFood;
            do {
                newFood = {
                    x: Math.floor(Math.random() * gridCount) * gridSize,
                    y: Math.floor(Math.random() * gridCount) * gridSize,
                    emoji: emoji
                };
            } while (
                snake.some(segment => segment.x === newFood.x && segment.y === newFood.y) ||
                foods.some(food => food.x === newFood.x && food.y === newFood.y)
            );
            foods.push(newFood);
        }

        // Draw grid
        function drawGrid() {
            ctx.strokeStyle = '#4A90E2'; // Ocean blue grid
            for (let i = 0; i <= canvas.width; i += gridSize) {
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i, canvas.height);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(0, i);
                ctx.lineTo(canvas.width, i);
                ctx.stroke();
            }
        }

        // Draw snake
        function drawSnake() {
            snake.forEach((segment, index) => {
                ctx.fillStyle = index === 0 ? headColor : tailColors[index % tailColors.length];
                ctx.beginPath();
                ctx.roundRect(segment.x + 2, segment.y + 2, gridSize - 4, gridSize - 4, 4);
                ctx.fill();
                ctx.strokeStyle = '#2E7D32'; // Jungle green outline
                ctx.lineWidth = 1;
                ctx.stroke();
            });
        }

        // Draw foods
        function drawFoods() {
            ctx.font = `${gridSize * 0.8}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            foods.forEach(food => {
                ctx.fillText(food.emoji, food.x + gridSize / 2, food.y + gridSize / 2);
            });
        }

        // Update game state
        function update() {
            if (gameOver) return;

            direction = nextDirection;
            const head = { x: snake[0].x, y: snake[0].y };
            if (direction === 'right') head.x += gridSize;
            if (direction === 'left') head.x -= gridSize;
            if (direction === 'up') head.y -= gridSize;
            if (direction === 'down') head.y += gridSize;

            // Check wall collision
            if (head.x < 0 || head.x >= canvas.width || head.y < 0 || head.y >= canvas.height) {
                gameOver = true;
                document.getElementById('gameOverScore').textContent = 'Lost on the Island! Items: ' + score;
                document.getElementById('gameOverPopup').style.display = 'block';
                return;
            }

            // Check self-collision
            if (snake.some(segment => segment.x === head.x && segment.y === head.y)) {
                gameOver = true;
                document.getElementById('gameOverScore').textContent = 'Lost on the Island! Items: ' + score;
                document.getElementById('gameOverPopup').style.display = 'block';
                return;
            }

            snake.unshift(head);

            // Check food collision
            let foodEatenIndex = -1;
            for (let i = 0; i < foods.length; i++) {
                if (head.x === foods[i].x && head.y === foods[i].y) {
                    foodEatenIndex = i;
                    break;
                }
            }
            if (foodEatenIndex !== -1) {
                score++;
                document.getElementById('score').textContent = 'Items Collected: ' + score;
                foods.splice(foodEatenIndex, 1);
                spawnFood();
                if (score >= 15) {
                    gameOver = true;
                    document.getElementById('winCode').textContent = generateCode();
                    document.getElementById('winPopup').style.display = 'block';
                    return;
                }
            } else {
                snake.pop();
            }
        }

        // Render frame
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawGrid();
            drawSnake();
            drawFoods();
        }

        // Game loop
        let lastTime = 0;
        const fps = 10;
        function gameLoop(timestamp) {
            if (!gameOver && timestamp - lastTime > 1000 / fps) {
                update();
                draw();
                lastTime = timestamp;
            }
            requestAnimationFrame(gameLoop);
        }

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowRight' && direction !== 'left') nextDirection = 'right';
            if (e.key === 'ArrowLeft' && direction !== 'right') nextDirection = 'left';
            if (e.key === 'ArrowUp' && direction !== 'down') nextDirection = 'up';
            if (e.key === 'ArrowDown' && direction !== 'up') nextDirection = 'down';
        });

        // Swipe controls
        let touchStartX = 0, touchStartY = 0;
        canvas.addEventListener('touchstart', (e) => {
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        });
        canvas.addEventListener('touchend', (e) => {
            const touchEndX = e.changedTouches[0].clientX;
            const touchEndY = e.changedTouches[0].clientY;
            const dx = touchEndX - touchStartX;
            const dy = touchEndY - touchStartY;
            if (Math.abs(dx) > Math.abs(dy)) {
                if (dx > 0 && direction !== 'left') nextDirection = 'right';
                if (dx < 0 && direction !== 'right') nextDirection = 'left';
            } else {
                if (dy > 0 && direction !== 'up') nextDirection = 'down';
                if (dy < 0 && direction !== 'down') nextDirection = 'up';
            }
        });

        // On-screen keypad buttons
        document.getElementById('up').addEventListener('click', () => { if (direction !== 'down') nextDirection = 'up'; });
        document.getElementById('down').addEventListener('click', () => { if (direction !== 'up') nextDirection = 'down'; });
        document.getElementById('left').addEventListener('click', () => { if (direction !== 'right') nextDirection = 'left'; });
        document.getElementById('right').addEventListener('click', () => { if (direction !== 'left') nextDirection = 'right'; });

        // Restart buttons
        document.getElementById('restartButton').addEventListener('click', () => {
            resetGame();
        });
        document.getElementById('winRestartButton').addEventListener('click', () => {
            resetGame();
        });

        // Start game
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>